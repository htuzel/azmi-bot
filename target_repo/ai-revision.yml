name: AI Revision

on:
  repository_dispatch:
    types: [ai-revision-task]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  BASE_BRANCH: main

jobs:
  opus-revision-plan:
    runs-on: ubuntu-latest
    env:
      JIRA_BASE: ${{ secrets.JIRA_BASE }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Extract payload
        id: payload
        run: |
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'

          # Create artifacts directory
          mkdir -p .artifacts

          # Extract simple fields
          echo "issue_key=$(jq -r '.issue_key' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT
          echo "title=$(jq -r '.title' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT
          echo "previous_pr_number=$(jq -r '.previous_pr_number // ""' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT

          # Extract multiline fields using EOF delimiter
          echo "revision_comment<<EOF" >> $GITHUB_OUTPUT
          jq -r '.revision_comment' <<< "$PAYLOAD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "description<<EOF" >> $GITHUB_OUTPUT
          jq -r '.description' <<< "$PAYLOAD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "image_context<<EOF" >> $GITHUB_OUTPUT
          jq -r '.image_context // ""' <<< "$PAYLOAD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Fetch previous PR changes
        id: pr-changes
        if: steps.payload.outputs.previous_pr_number != ''
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_NUMBER="${{ steps.payload.outputs.previous_pr_number }}"

          if [ -z "$PR_NUMBER" ]; then
            echo "No previous PR number provided"
            echo "has_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Fetching PR #$PR_NUMBER details..."

          # Get PR diff
          mkdir -p .artifacts
          gh pr diff "$PR_NUMBER" > .artifacts/previous-pr.diff || true

          # Get PR details
          gh pr view "$PR_NUMBER" --json title,body,files > .artifacts/pr-details.json || true

          if [ -f .artifacts/previous-pr.diff ]; then
            echo "has_pr=true" >> $GITHUB_OUTPUT
            echo "Previous PR diff saved to .artifacts/previous-pr.diff"

            # Output PR summary
            echo "pr_summary<<EOF" >> $GITHUB_OUTPUT
            echo "## Previous PR #$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "**Title:** $(jq -r '.title' .artifacts/pr-details.json)" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "**Files Changed:**" >> $GITHUB_OUTPUT
            jq -r '.files[] | "- \(.path)"' .artifacts/pr-details.json >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "**Diff:**" >> $GITHUB_OUTPUT
            echo '```diff' >> $GITHUB_OUTPUT
            head -n 200 .artifacts/previous-pr.diff >> $GITHUB_OUTPUT
            echo '```' >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_pr=false" >> $GITHUB_OUTPUT
          fi

      - name: Claude Opus 4.5 - create revision plan
        id: opus-plan
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GH_PAT }}
          show_full_output: true
          prompt: |
            You are a senior software architect using Claude Opus 4.5. Create a REVISION PLAN for an existing implementation.

            IMPORTANT:
            - You are ONLY creating a revision plan, NOT implementing code
            - Output the FULL PLAN as markdown text
            - Do NOT create any files or make any code changes
            - Just analyze and output the plan to stdout

            NOTE: This ticket may have attached images showing visual context (UI mockups, bugs, before/after). The implementation agent will receive these images during implementation.

            CONTEXT:
            This is a Next.js 14 (App Router) + PostgreSQL + Socket.IO sales platform.

            ORIGINAL TASK:
            - ID: ${{ steps.payload.outputs.issue_key }}
            - Title: ${{ steps.payload.outputs.title }}
            - Description: ${{ steps.payload.outputs.description }}

            PREVIOUS IMPLEMENTATION:
            ${{ steps.pr-changes.outputs.has_pr == 'true' && steps.pr-changes.outputs.pr_summary || 'No previous PR available - this may be a new revision request without PR context.' }}

            REVISION REQUEST:
            ${{ steps.payload.outputs.revision_comment }}

            FIRST: Read and understand the codebase:
            - Read TSD.md for architecture overview
            - Examine the files mentioned in the previous PR
            - Understand what was implemented and what needs to change

            THEN: Output your revision plan in this format:

            # Revision Plan for ${{ steps.payload.outputs.issue_key }}

            ## 1. Revision Summary
            [1-2 sentences: What needs to be changed and why]

            ## 2. Changes Needed
            **Files to modify:**
            - `path/to/file1.ts` - [specific changes needed]
            - `path/to/file2.tsx` - [specific changes needed]

            **What to fix/improve:**
            - [Specific issue 1 and how to fix it]
            - [Specific issue 2 and how to fix it]

            ## 3. Implementation Steps
            **Step 1: [Category of changes]**
            - Specific change 1
            - Specific change 2

            **Step 2: [Next category]**
            - Specific change 1
            - Specific change 2

            ## 4. Code Examples
            For each file to modify, provide the COMPLETE updated code:

            ### File: `path/to/file.ts`
            ```typescript
            // Complete implementation code here
            ```

            ## 5. Testing Requirements
            **New/Updated Tests:**
            - Test [specific scenario]
            - Verify [specific behavior]

            **Manual Verification:**
            - [How to verify the fix works]

            ## 6. Acceptance Criteria
            - [ ] [Specific testable criterion 1]
            - [ ] [Specific testable criterion 2]
            - [ ] [Original issue is resolved]

            CRITICAL RULES:
            1. Read the codebase first to understand existing implementation
            2. Output the COMPLETE plan with FULL CODE EXAMPLES
            3. Be specific with file paths
            4. Reference the previous implementation when suggesting changes
            5. Keep changes minimal - only address what was requested
          claude_args: |
            --dangerously-skip-permissions
            --max-turns 30
            --model claude-opus-4-5-20251101

      - name: Save revision plan
        run: |
          mkdir -p .artifacts
          cat > .artifacts/REVISION_PLAN.md << 'EOF'
          ${{ steps.opus-plan.outputs.response }}
          EOF

      - name: Upload revision plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: revision-plan
          path: .artifacts/REVISION_PLAN.md

  gemini-implement-revision:
    runs-on: ubuntu-latest
    needs: opus-revision-plan
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GH_TOKEN: ${{ secrets.GH_PAT }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/download-artifact@v4
        with:
          name: revision-plan
          path: .artifacts

      - name: Read revision plan
        id: read-plan
        run: |
          PLAN=$(cat .artifacts/REVISION_PLAN.md)
          echo "plan<<EOF" >> $GITHUB_OUTPUT
          echo "$PLAN" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Extract payload
        id: payload
        run: |
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'
          echo "issue_key=$(jq -r '.issue_key' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT
          echo "previous_pr_number=$(jq -r '.previous_pr_number // ""' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT

      - name: Install ImageMagick for image optimization
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick
          echo "‚úÖ ImageMagick installed for PDF conversion and image optimization"

      - name: Securely fetch images from Jira
        id: fetch-images
        env:
          JIRA_BASE: ${{ secrets.JIRA_BASE }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        run: |
          ISSUE_KEY="${{ steps.payload.outputs.issue_key }}"

          # SECURITY: Never trust payload images - always re-fetch from Jira API
          bash .github/scripts/fetch-jira-attachments.sh \
            "$JIRA_BASE" "$ISSUE_KEY" "$JIRA_EMAIL" "$JIRA_API_TOKEN"

          # Check if images were fetched
          if [ -f .artifacts/images.json ]; then
            IMAGE_COUNT=$(jq '. | length' .artifacts/images.json)
            echo "image_count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Securely fetched and optimized $IMAGE_COUNT image(s)"
          else
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo "image_count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No images attached to this revision"
          fi

      - name: Build image context
        if: steps.fetch-images.outputs.has_images == 'true'
        id: image-context
        run: |
          bash .github/scripts/build-image-context.sh

          if [ -f .artifacts/image-context.md ]; then
            echo "context<<EOF" >> $GITHUB_OUTPUT
            cat .artifacts/image-context.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Image context built successfully"
          fi

      - name: Setup Git
        run: |
          git config user.name "Azmi Bot"
          git config user.email "azmi-bot@users.noreply.github.com"

      - name: Create revision branch
        id: branch
        run: |
          ISSUE_KEY="${{ steps.payload.outputs.issue_key || 'ai-revision' }}"
          BRANCH_NAME="revision/${ISSUE_KEY}"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Created branch: $BRANCH_NAME"

      - name: Gemini 3 Pro - implement revision from plan
        id: gemini-implement
        shell: bash
        run: |
          set -euo pipefail

          echo "üöÄ Starting Gemini 3 Pro revision implementation..."

          # Read the plan
          PLAN=$(cat .artifacts/REVISION_PLAN.md)
          PREVIOUS_PR="${{ steps.payload.outputs.previous_pr_number }}"

          # Build the implementation prompt
          cat > .artifacts/revision-prompt.txt << 'PROMPT_EOF'
          You are a senior software engineer implementing code revisions based on a detailed plan.

          TASK: Implement the revision changes described in the plan below.

          IMPORTANT OUTPUT FORMAT:
          You must output a JSON object with this exact structure:
          {
            "files": [
              {
                "path": "relative/path/to/file.ts",
                "action": "create" | "modify" | "delete",
                "content": "full file content here"
              }
            ],
            "commit_message": "descriptive commit message for the revision",
            "pr_body": "markdown description of changes made"
          }

          RULES:
          1. For "create" action: provide the complete new file content
          2. For "modify" action: provide the COMPLETE file content (not just changes)
          3. For "delete" action: content can be empty
          4. Follow the revision plan exactly - implement only what was requested
          5. Make minimal, surgical changes - do not refactor unrelated code
          6. Use TypeScript/JavaScript best practices
          7. Include proper error handling

          REVISION PLAN:
          ---
          PROMPT_EOF

          echo "$PLAN" >> .artifacts/revision-prompt.txt

          if [ -n "$PREVIOUS_PR" ]; then
            echo "" >> .artifacts/revision-prompt.txt
            echo "PREVIOUS PR: #$PREVIOUS_PR" >> .artifacts/revision-prompt.txt
          fi

          # Build Gemini request
          jq -n \
            --rawfile prompt .artifacts/revision-prompt.txt \
            '{
              contents: [{
                role: "user",
                parts: [{text: $prompt}]
              }],
              generationConfig: {
                responseMimeType: "application/json",
                temperature: 0.2,
                maxOutputTokens: 65536
              }
            }' > .artifacts/gemini-revision-request.json

          echo "üì§ Sending revision request to Gemini 3 Pro..."

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro:generateContent" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @.artifacts/gemini-revision-request.json > .artifacts/gemini-response.json

          echo "üì• Response received"

          # Extract the JSON response
          RESPONSE_TEXT=$(jq -r '.candidates[0].content.parts[0].text' .artifacts/gemini-response.json)
          echo "$RESPONSE_TEXT" > .artifacts/revision-implementation.json

          echo "‚úÖ Revision implementation parsed"

      - name: Apply revision changes
        id: apply-changes
        shell: bash
        run: |
          set -euo pipefail

          echo "üìù Applying revision changes..."

          # Parse the implementation JSON
          IMPL_JSON=$(cat .artifacts/revision-implementation.json)

          # Process each file
          echo "$IMPL_JSON" | jq -c '.files[]' | while IFS= read -r file; do
            FILE_PATH=$(echo "$file" | jq -r '.path')
            ACTION=$(echo "$file" | jq -r '.action')
            CONTENT=$(echo "$file" | jq -r '.content')

            echo "Processing: $FILE_PATH ($ACTION)"

            case "$ACTION" in
              "create"|"modify")
                mkdir -p "$(dirname "$FILE_PATH")"
                echo "$CONTENT" > "$FILE_PATH"
                echo "‚úÖ Written: $FILE_PATH"
                ;;
              "delete")
                if [ -f "$FILE_PATH" ]; then
                  rm "$FILE_PATH"
                  echo "üóëÔ∏è  Deleted: $FILE_PATH"
                fi
                ;;
            esac
          done

          # Extract commit message and PR body
          echo "$IMPL_JSON" | jq -r '.commit_message' > .artifacts/commit-message.txt
          echo "$IMPL_JSON" | jq -r '.pr_body' > .artifacts/pr-body.txt

          echo "‚úÖ All revision changes applied"

      - name: Commit and push changes
        id: commit
        run: |
          ISSUE_KEY="${{ steps.payload.outputs.issue_key || 'ai-revision' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          # Check if there are changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No changes to commit"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git add -A

          # Use commit message from Gemini or default
          if [ -f .artifacts/commit-message.txt ]; then
            COMMIT_MSG=$(cat .artifacts/commit-message.txt)
          else
            COMMIT_MSG="Revision: ${ISSUE_KEY}"
          fi

          git commit -m "$COMMIT_MSG

          ü§ñ Implemented by Gemini 3 Pro
          üìã Planned by Claude Opus 4.5"

          git push -u origin "$BRANCH_NAME"

          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Revision changes committed and pushed to $BRANCH_NAME"

      - name: Create Pull Request
        if: steps.commit.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ISSUE_KEY="${{ steps.payload.outputs.issue_key || 'ai-revision' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"
          PREVIOUS_PR="${{ steps.payload.outputs.previous_pr_number }}"

          # Build PR body
          if [ -f .artifacts/pr-body.txt ]; then
            PR_DESCRIPTION=$(cat .artifacts/pr-body.txt)
          else
            PR_DESCRIPTION="Revision implementation for ${ISSUE_KEY}"
          fi

          # Read the plan for PR body
          PLAN=$(cat .artifacts/REVISION_PLAN.md)

          PR_BODY="## üîÑ AZMI Revision - ${ISSUE_KEY}

          ### Previous PR
          ${PREVIOUS_PR:+#$PREVIOUS_PR}${PREVIOUS_PR:-N/A}

          ### Revision Plan (by Claude Opus 4.5)
          <details>
          <summary>Click to expand plan</summary>

          ${PLAN}

          </details>

          ### Changes Made (by Gemini 3 Pro)
          ${PR_DESCRIPTION}

          ---
          üß† **Planned by:** Claude Opus 4.5
          ‚ö° **Implemented by:** Gemini 3 Pro
          "

          # Create PR
          gh pr create \
            --title "AZMI Revision - ${ISSUE_KEY}" \
            --body "$PR_BODY" \
            --base "${{ env.BASE_BRANCH }}" \
            --head "$BRANCH_NAME"

          echo "‚úÖ Revision Pull Request created"
