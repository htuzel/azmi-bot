# ==============================================================================
# AI Coding Workflow - Gemini Plans, Claude Opus Implements
# ==============================================================================
# This workflow automates code implementation from Jira tickets using AI:
# 1. Gemini 3 Pro creates a detailed implementation plan
# 2. Claude Opus 4.5 evaluates, revises if needed, and implements the code
#
# Required Secrets:
# - GEMINI_API_KEY: Google AI API key for Gemini
# - ANTHROPIC_API_KEY: Anthropic API key for Claude
# - GH_PAT: GitHub Personal Access Token with repo permissions
# - JIRA_BASE: Jira instance URL (e.g., https://company.atlassian.net)
# - JIRA_EMAIL: Jira account email
# - JIRA_API_TOKEN: Jira API token
#
# Required Scripts (in .github/scripts/):
# - fetch-jira-attachments.sh: Downloads and optimizes images from Jira
# - build-image-context.sh: Prepares images for AI consumption
# ==============================================================================

name: AI Coding

on:
  repository_dispatch:
    types: [ai-coding-task]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  # CUSTOMIZE: Change to your default branch (main, master, develop, etc.)
  BASE_BRANCH: develop

jobs:
  gemini-plan:
    runs-on: ubuntu-latest
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      JIRA_BASE: ${{ secrets.JIRA_BASE }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Clean artifacts directory
        run: rm -rf .artifacts && mkdir -p .artifacts

      - name: Extract issue_key from payload
        id: payload
        run: |
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'
          echo "issue_key=$(jq -r '.issue_key' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT

      - name: Fetch issue from Jira
        id: jira
        shell: bash
        run: |
          set -euo pipefail

          ISSUE=$(jq -r '.issue_key' <<< '${{ toJSON(github.event.client_payload) }}')

          if [ -z "$ISSUE" ] || [ "$ISSUE" = "null" ]; then
            echo "ERROR: Issue key is missing from payload"
            exit 1
          fi

          echo "Fetching issue: $ISSUE from Jira..."

          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          mkdir -p .artifacts
          curl -sS -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            "$JIRA_BASE/rest/api/3/issue/$ISSUE?expand=renderedFields" \
            -o .artifacts/jira-issue.json

          echo "Issue fetched successfully"

          TITLE=$(jq -r '.fields.summary' .artifacts/jira-issue.json)
          DESCRIPTION=$(jq -r '.renderedFields.description // "No description"' .artifacts/jira-issue.json)

          echo "Title: $TITLE"
          echo "Description preview: ${DESCRIPTION:0:100}..."

          # Save to files for Gemini prompt
          echo "$TITLE" > .artifacts/jira-title.txt
          echo "$DESCRIPTION" > .artifacts/jira-description.txt

          echo "title=$TITLE" >> $GITHUB_OUTPUT

      - name: Install ImageMagick for image optimization
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick
          echo "âœ… ImageMagick installed"

      - name: Fetch and optimize Jira images
        id: fetch-images
        run: |
          ISSUE=$(jq -r '.issue_key' <<< '${{ toJSON(github.event.client_payload) }}')

          bash .github/scripts/fetch-jira-attachments.sh \
            "$JIRA_BASE" "$ISSUE" "$JIRA_EMAIL" "$JIRA_API_TOKEN"

          if [ -f .artifacts/images.json ]; then
            IMAGE_COUNT=$(jq '.count // (. | length)' .artifacts/images.json 2>/dev/null || echo "0")
            echo "image_count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "âœ… Fetched $IMAGE_COUNT image(s)"
          else
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo "image_count=0" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No images attached"
          fi

      - name: Build docs context
        id: docs-context
        run: |
          # Create a summary of available documentation
          # CUSTOMIZE: Adjust the docs path if your project uses a different location
          echo "# Project Documentation" > .artifacts/docs-summary.txt
          echo "" >> .artifacts/docs-summary.txt

          # Try common documentation locations
          for docs_dir in docs doc documentation; do
            if [ -d "$docs_dir" ]; then
              for doc in "$docs_dir"/*.md; do
                if [ -f "$doc" ]; then
                  echo "## $(basename "$doc" .md)" >> .artifacts/docs-summary.txt
                  head -30 "$doc" >> .artifacts/docs-summary.txt
                  echo "" >> .artifacts/docs-summary.txt
                  echo "---" >> .artifacts/docs-summary.txt
                  echo "" >> .artifacts/docs-summary.txt
                fi
              done
            fi
          done

          # Also check for TSD.md, README.md, ARCHITECTURE.md at root
          for doc in TSD.md README.md ARCHITECTURE.md CONTRIBUTING.md; do
            if [ -f "$doc" ]; then
              echo "## $doc" >> .artifacts/docs-summary.txt
              head -50 "$doc" >> .artifacts/docs-summary.txt
              echo "" >> .artifacts/docs-summary.txt
              echo "---" >> .artifacts/docs-summary.txt
            fi
          done

          echo "âœ… Docs context built"

      - name: Gemini 3 Pro - produce plan (TSD)
        id: gemini-plan
        shell: bash
        run: |
          set -euo pipefail

          ISSUE_KEY="${{ steps.payload.outputs.issue_key }}"
          TITLE=$(cat .artifacts/jira-title.txt)
          DESCRIPTION=$(cat .artifacts/jira-description.txt)
          DOCS_CONTEXT=$(cat .artifacts/docs-summary.txt 2>/dev/null || echo "No docs available")

          echo "ðŸ§  Creating implementation plan with Gemini 3 Pro..."

          # Build the planning prompt
          # CUSTOMIZE: Update PLATFORM CONTEXT to describe YOUR project
          cat > .artifacts/plan-prompt.txt << PROMPT_EOF
          You are a senior software architect. Create a COMPLETE implementation plan for a Jira task.

          PLATFORM CONTEXT:
          # ============================================================================
          # CUSTOMIZE THIS SECTION FOR YOUR PROJECT
          # ============================================================================
          # Describe your project's:
          # - Tech stack (e.g., "Next.js 14 + PostgreSQL + Prisma")
          # - Architecture (e.g., "Microservices with API Gateway")
          # - Key features (e.g., "E-commerce platform with real-time inventory")
          # - Important patterns (e.g., "Repository pattern, CQRS")
          # ============================================================================

          PROJECT DOCUMENTATION:
          $DOCS_CONTEXT

          TASK TO PLAN:
          - ID: $ISSUE_KEY
          - Title: $TITLE
          - Description:
          $DESCRIPTION

          CREATE A DETAILED IMPLEMENTATION PLAN with:

          1. GOAL: Clear 1-2 sentence summary

          2. SCOPE:
             - Files to create/modify (with exact paths)
             - Database changes needed
             - Modules affected

          3. IMPLEMENTATION STEPS:
             - Step 1: Database/Schema changes
             - Step 2: Backend/API changes
             - Step 3: Frontend/UI changes
             - Step 4: Integration points

          4. CODE EXAMPLES:
             - Provide COMPLETE code for each file
             - Include proper imports, types, error handling
             - Follow project's existing patterns and best practices

          5. ACCEPTANCE CRITERIA:
             - Specific testable criteria

          6. RISKS AND MITIGATIONS

          7. DEPLOYMENT RUNBOOK

          Be specific with file paths and provide COMPLETE, WORKING code examples.
          PROMPT_EOF

          # Build Gemini request
          jq -n \
            --rawfile prompt .artifacts/plan-prompt.txt \
            '{
              contents: [{
                role: "user",
                parts: [{text: $prompt}]
              }],
              generationConfig: {
                temperature: 0.3,
                maxOutputTokens: 65536
              }
            }' > .artifacts/gemini-plan-request.json

          # Check if we have images
          if [ -f .artifacts/images.json ] && [ "${{ steps.fetch-images.outputs.has_images }}" = "true" ]; then
            echo "ðŸ–¼ï¸ Adding images to request..."

            # Start with text part
            jq -n --rawfile text .artifacts/plan-prompt.txt '[{text: $text}]' > .artifacts/parts-array.json

            # Add each image
            IMAGE_INDEX=0
            jq -c '.images[]' .artifacts/images.json 2>/dev/null | while IFS= read -r image; do
              IMAGE_INDEX=$((IMAGE_INDEX + 1))

              echo "$image" | jq -r '.data_uri' | sed 's/data:image\/[^;]*;base64,//' | tr -d '\n\r' > .artifacts/image-b64-${IMAGE_INDEX}.txt
              MIME_TYPE=$(echo "$image" | jq -r '.data_uri' | sed -n 's/data:\([^;]*\);base64,.*/\1/p')

              B64_DATA=$(cat .artifacts/image-b64-${IMAGE_INDEX}.txt)

              jq --arg b64 "$B64_DATA" --arg mime "$MIME_TYPE" \
                '. += [{inline_data: {mime_type: $mime, data: $b64}}]' \
                .artifacts/parts-array.json > .artifacts/parts-array-tmp.json

              mv .artifacts/parts-array-tmp.json .artifacts/parts-array.json
            done

            # Build multimodal request
            jq -n \
              --slurpfile parts .artifacts/parts-array.json \
              '{
                contents: [{
                  role: "user",
                  parts: $parts[0]
                }],
                generationConfig: {
                  temperature: 0.3,
                  maxOutputTokens: 65536
                }
              }' > .artifacts/gemini-plan-request.json
          fi

          echo "ðŸ“¤ Sending request to Gemini 3 Pro..."
          echo "Request size: $(wc -c < .artifacts/gemini-plan-request.json) bytes"

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @.artifacts/gemini-plan-request.json > .artifacts/gemini-plan-response.json

          echo "ðŸ“¥ Response received"

          # Check for errors
          if jq -e '.error' .artifacts/gemini-plan-response.json > /dev/null 2>&1; then
            echo "âŒ Gemini API Error:"
            jq '.error' .artifacts/gemini-plan-response.json
            exit 1
          fi

          # Extract plan from response
          PLAN=$(jq -r '.candidates[0].content.parts[0].text // empty' .artifacts/gemini-plan-response.json)

          if [ -z "$PLAN" ] || [ ${#PLAN} -lt 100 ]; then
            echo "âŒ ERROR: Plan is empty or too short!"
            cat .artifacts/gemini-plan-response.json
            exit 1
          fi

          # Add issue ID header if not present
          if ! echo "$PLAN" | grep -q "$ISSUE_KEY"; then
            echo "# Implementation Plan for $ISSUE_KEY" > .artifacts/PLAN.md
            echo "" >> .artifacts/PLAN.md
            echo "$PLAN" >> .artifacts/PLAN.md
          else
            echo "$PLAN" > .artifacts/PLAN.md
          fi

          PLAN_SIZE=$(wc -c < .artifacts/PLAN.md)
          echo "âœ… Plan created: $PLAN_SIZE bytes"
          head -50 .artifacts/PLAN.md

      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: ai-plan-${{ github.run_id }}
          path: .artifacts/PLAN.md
          retention-days: 1

      - name: Upload images artifact
        if: steps.fetch-images.outputs.has_images == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ai-images-${{ github.run_id }}
          path: .artifacts/images/
          retention-days: 1

  opus-implement:
    runs-on: ubuntu-latest
    needs: gemini-plan
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GH_TOKEN: ${{ secrets.GH_PAT }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean artifacts directory
        run: rm -rf .artifacts && mkdir -p .artifacts

      - uses: actions/download-artifact@v4
        with:
          name: ai-plan-${{ github.run_id }}
          path: .artifacts

      - name: Download images artifact
        id: download-images
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: ai-images-${{ github.run_id }}
          path: .artifacts/images

      - name: Verify plan artifact
        env:
          ISSUE_KEY: ${{ github.event.client_payload.issue_key }}
        run: |
          echo "ðŸ“„ Verifying plan for issue: $ISSUE_KEY"

          if [ ! -f .artifacts/PLAN.md ]; then
            echo "âŒ PLAN.md not found!"
            ls -la .artifacts/
            exit 1
          fi

          PLAN_SIZE=$(wc -c < .artifacts/PLAN.md)
          echo "Plan size: $PLAN_SIZE bytes"

          if [ "$PLAN_SIZE" -lt 100 ]; then
            echo "âŒ ERROR: Plan is empty!"
            cat .artifacts/PLAN.md
            exit 1
          fi

          if ! grep -q "$ISSUE_KEY" .artifacts/PLAN.md; then
            echo "âŒ ERROR: Plan is for wrong issue!"
            echo "Expected: $ISSUE_KEY"
            head -5 .artifacts/PLAN.md
            exit 1
          fi

          echo "âœ… Plan validated for $ISSUE_KEY"

      - name: Setup Git
        run: |
          # CUSTOMIZE: Change bot name and email if desired
          git config user.name "Azmi Bot"
          git config user.email "azmi-bot@users.noreply.github.com"

      - name: Create feature branch
        id: branch
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="feature/${ISSUE_KEY}"

          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "ðŸ—‘ï¸ Deleting existing remote branch: $BRANCH_NAME"
            git push origin --delete "$BRANCH_NAME" || true
          fi

          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "âœ… Created branch: $BRANCH_NAME"

      - name: Claude Opus 4.5 - evaluate, revise & implement
        id: opus-implement
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GH_PAT }}
          show_full_output: true
          # CUSTOMIZE: Update PLATFORM CONTEXT to describe YOUR project
          prompt: |
            You are a senior software engineer and technical lead. Your job is to:
            1. EVALUATE the implementation plan
            2. REVISE it if needed
            3. IMPLEMENT the code changes

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            PHASE 1: EVALUATE THE PLAN
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            Read the plan from: .artifacts/PLAN.md

            Evaluate it against these criteria:
            - Is the goal clear and correctly understood?
            - Are file paths specific and correct for this codebase?
            - Are code examples complete with proper imports/types?
            - Is the approach feasible and following best practices?
            - Are there any missing pieces or incorrect assumptions?

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            PHASE 2: REVISE IF NEEDED
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            If the plan has issues:
            - Identify what's wrong or missing
            - Read the actual codebase to understand existing patterns
            - Create a REVISED plan that fixes the issues
            - Save the revised plan to .artifacts/PLAN-REVISED.md

            If the plan is good as-is, proceed directly to implementation.

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            PHASE 3: IMPLEMENT
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            Using the plan (original or revised), implement ALL changes.

            # ============================================================================
            # CUSTOMIZE: Update this section with YOUR project's context
            # ============================================================================
            # PLATFORM CONTEXT:
            # - Your tech stack (e.g., "Next.js 14 + PostgreSQL")
            # - Key directories (e.g., "src/, app/, lib/")
            # - Important files (e.g., "Routes in app/api/")
            # ============================================================================

            IMPLEMENTATION RULES:
            1. READ existing files before modifying them
            2. Use the Write tool to create/modify files
            3. Write COMPLETE file contents (not partial updates)
            4. Follow existing code patterns in the repo
            5. Include proper error handling and types
            6. Do NOT create test files unless explicitly needed
            7. Do NOT modify unrelated files

            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            IMPORTANT: YOU MUST COMPLETE ALL THREE PHASES
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            Do not stop after evaluation. Do not stop after revision.
            Your job is to deliver WORKING CODE at the end.

            Start by reading .artifacts/PLAN.md now.
          claude_args: |
            --dangerously-skip-permissions
            --max-turns 75
            --model claude-opus-4-5-20251101

      - name: Commit and push changes
        id: commit
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          # Check if there are changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "âš ï¸ No changes to commit"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git add -A

          # Don't commit .artifacts
          git reset .artifacts/ 2>/dev/null || true

          # Check again after reset
          if git diff --staged --quiet; then
            echo "âš ï¸ No changes to commit (only artifacts)"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git commit -m "feat($ISSUE_KEY): Implement changes from AI plan

          ðŸ¤– Implemented by Claude Opus 4.5
          ðŸ“‹ Planned by Gemini 3 Pro"

          git push -u origin "$BRANCH_NAME"

          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "âœ… Changes committed and pushed to $BRANCH_NAME"

      - name: Create Pull Request
        if: steps.commit.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          PLAN=$(cat .artifacts/PLAN.md)

          PR_BODY="## ðŸ¤– AI Coding - ${ISSUE_KEY}

          ### Implementation Plan (by Gemini 3 Pro)
          <details>
          <summary>Click to expand plan</summary>

          ${PLAN}

          </details>

          ---
          ðŸ§  **Planned by:** Gemini 3 Pro
          âš¡ **Implemented by:** Claude Opus 4.5
          "

          gh pr create \
            --title "AI Coding - ${ISSUE_KEY}" \
            --body "$PR_BODY" \
            --base "${{ env.BASE_BRANCH }}" \
            --head "$BRANCH_NAME"

          echo "âœ… Pull Request created"

      - name: Post implementation status to Jira
        if: always()
        env:
          JIRA_BASE: ${{ secrets.JIRA_BASE }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        run: |
          ISSUE_KEY='${{ github.event.client_payload.issue_key }}'

          if [ -z "$ISSUE_KEY" ] || [ "$ISSUE_KEY" = "null" ]; then
            echo "No Jira issue key found, skipping"
            exit 0
          fi

          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          jq -n \
            --arg repo "${{ github.repository }}" \
            --arg workflow_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{
              body: {
                type: "doc",
                version: 1,
                content: [
                  {
                    type: "heading",
                    attrs: { level: 2 },
                    content: [{ type: "text", text: "ðŸ¤– AI Implementation Started" }]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Implementation in progress using Gemini 3 Pro (planning) + Claude Opus 4.5 (coding)." }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Repository: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $repo }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Workflow: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $workflow_url, marks: [{ type: "link", attrs: { href: $workflow_url } }] }
                    ]
                  }
                ]
              }
            }' > /tmp/jira-comment.json

          curl -sS -X POST "$JIRA_BASE/rest/api/3/issue/$ISSUE_KEY/comment" \
            -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d @/tmp/jira-comment.json

          echo "âœ… Posted status to Jira"
