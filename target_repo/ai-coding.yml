name: AI Coding

on:
  repository_dispatch:
    types: [ai-coding-task]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  BASE_BRANCH: develop

jobs:
  opus-plan:
    runs-on: ubuntu-latest
    env:
      JIRA_BASE: ${{ secrets.JIRA_BASE }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Extract issue_key from payload
        id: payload
        run: |
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'
          echo "issue_key=$(jq -r '.issue_key' <<< "$PAYLOAD")" >> $GITHUB_OUTPUT

      - name: Fetch issue from Jira
        id: jira
        shell: bash
        run: |
          set -euo pipefail

          ISSUE=$(jq -r '.issue_key' <<< '${{ toJSON(github.event.client_payload) }}')

          if [ -z "$ISSUE" ] || [ "$ISSUE" = "null" ]; then
            echo "ERROR: Issue key is missing from payload"
            exit 1
          fi

          echo "Fetching issue: $ISSUE from Jira..."
          echo "JIRA_BASE: $JIRA_BASE"
          echo "JIRA_EMAIL: $JIRA_EMAIL"
          echo "Full URL: $JIRA_BASE/rest/api/3/issue/$ISSUE?expand=renderedFields"

          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          mkdir -p .artifacts
          curl -sS -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            "$JIRA_BASE/rest/api/3/issue/$ISSUE?expand=renderedFields" \
            -o .artifacts/jira-issue.json

          echo "Issue fetched successfully"

          TITLE=$(jq -r '.fields.summary' .artifacts/jira-issue.json)
          # Use renderedFields.description (HTML string) instead of fields.description (ADF JSON)
          DESCRIPTION=$(jq -r '.renderedFields.description // "No description"' .artifacts/jira-issue.json)

          echo "Title: $TITLE"
          echo "Description preview: ${DESCRIPTION:0:100}..."

          # Multi-line output requires EOF delimiter in GitHub Actions
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "description<<EOF" >> $GITHUB_OUTPUT
          echo "$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Install ImageMagick for image optimization
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick
          echo "‚úÖ ImageMagick installed for PDF conversion and image optimization"

      - name: Fetch and optimize Jira images
        id: fetch-images
        run: |
          ISSUE=$(jq -r '.issue_key' <<< '${{ toJSON(github.event.client_payload) }}')

          # Fetch images from Jira (downloads, optimizes, base64 encodes)
          bash .github/scripts/fetch-jira-attachments.sh \
            "$JIRA_BASE" "$ISSUE" "$JIRA_EMAIL" "$JIRA_API_TOKEN"

          # Check if images were fetched
          if [ -f .artifacts/images.json ]; then
            IMAGE_COUNT=$(jq '. | length' .artifacts/images.json)
            echo "image_count=$IMAGE_COUNT" >> $GITHUB_OUTPUT
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Fetched and optimized $IMAGE_COUNT image(s)"
          else
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo "image_count=0" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No images attached to this ticket"
          fi

      - name: Build image context for AI
        if: steps.fetch-images.outputs.has_images == 'true'
        id: image-context
        run: |
          # Build markdown with embedded images
          bash .github/scripts/build-image-context.sh

          # Read the generated context
          if [ -f .artifacts/image-context.md ]; then
            echo "context<<EOF" >> $GITHUB_OUTPUT
            cat .artifacts/image-context.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Image context built successfully"
          fi

      - name: Claude Opus 4.5 - produce plan (TSD)
        id: opus-plan
        uses: anthropics/claude-code-action@v1
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GH_PAT }}
          show_full_output: true
          prompt: |
            You are a senior software architect using Claude Opus 4.5. Your task is to create a COMPLETE, ACTIONABLE implementation plan.

            IMPORTANT:
            - You are ONLY creating a plan, NOT implementing code
            - Output the FULL PLAN as markdown text
            - Do NOT create any files or make any code changes
            - Just analyze and output the plan to stdout

            Context: This is a Next.js 14 (App Router) + PostgreSQL + Socket.IO sales platform. The codebase has TSD.md with architecture overview, but you must create NEW specific implementation steps for THIS task.

            Task to Plan:
            - ID: ${{ steps.payload.outputs.issue_key }}
            - Title: ${{ steps.jira.outputs.title }}
            - Description:
            ${{ steps.jira.outputs.description }}

            ${{ steps.fetch-images.outputs.has_images == 'true' && format('NOTE: This ticket has {0} attached image(s) showing visual context (UI mockups, screenshots, diagrams). The implementation agent will receive these images. Include visual considerations in your plan where relevant.', steps.fetch-images.outputs.image_count) || '' }}

            FIRST: Read and understand the codebase structure:
            - Read TSD.md for architecture overview
            - Explore relevant directories to understand patterns
            - Check existing similar implementations

            THEN: Output your plan in this format:

            # Implementation Plan for ${{ steps.payload.outputs.issue_key }}

            ## 1. Goal
            [Clear 1-2 sentence summary of what needs to be implemented]

            ## 2. Scope
            **Files to create/modify:**
            - `path/to/file1.ts` - [what changes]
            - `path/to/file2.tsx` - [what changes]
            - `path/to/file3.sql` - [what changes]

            **Modules affected:**
            - [list affected modules/features]

            ## 3. Implementation Steps
            **Step 1: [Database/Schema Changes]**
            - Specific SQL changes needed
            - Table/column additions or modifications
            - Migration file path

            **Step 2: [Backend/API Changes]**
            - API routes to create/modify (with paths)
            - Helper functions to add/update
            - Types/interfaces to define

            **Step 3: [Frontend/UI Changes]**
            - Components to create/modify
            - UI flow changes
            - State management updates

            **Step 4: [Integration]**
            - How components connect
            - API integration points
            - Socket events if needed

            ## 4. Acceptance Criteria
            - [ ] [Specific testable criterion 1]
            - [ ] [Specific testable criterion 2]
            - [ ] [Specific testable criterion 3]
            - [ ] [Add 3-6 total checkboxes]

            ## 5. Code Examples
            For each file to create/modify, provide the COMPLETE code:

            ### File: `path/to/file.ts`
            ```typescript
            // Complete implementation code here
            ```

            ## 6. Risks and Mitigations
            - **Risk:** [specific risk]
              **Mitigation:** [how to handle it]

            ## 7. Runbook
            **To Deploy:**
            ```bash
            [specific commands]
            ```

            **To Verify:**
            - [How to check it's working]

            CRITICAL RULES:
            1. Read the codebase first to understand existing patterns
            2. Output the COMPLETE plan with FULL CODE EXAMPLES
            3. Be specific with file paths (use actual repo structure)
            4. Include concrete implementation details that can be directly used
            5. If task seems already implemented, state that clearly
          claude_args: |
            --dangerously-skip-permissions
            --max-turns 30
            --model claude-opus-4-5-20251101

      - name: Save plan to artifact
        run: |
          mkdir -p .artifacts
          cat > .artifacts/PLAN.md << 'EOF'
          ${{ steps.opus-plan.outputs.response }}
          EOF
      - name: Upload plan artifact
        uses: actions/upload-artifact@v4
        with:
          name: ai-plan
          path: .artifacts/PLAN.md

      - name: Upload image context artifact
        if: steps.fetch-images.outputs.has_images == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: image-context
          path: .artifacts/image-context.md

  gemini-implement:
    runs-on: ubuntu-latest
    needs: opus-plan
    permissions:
      contents: write
      pull-requests: write
      issues: write
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GH_TOKEN: ${{ secrets.GH_PAT }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/download-artifact@v4
        with:
          name: ai-plan
          path: .artifacts

      - name: Download image context artifact
        id: download-images
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: image-context
          path: .artifacts

      - name: Read plan from artifact
        id: read-plan
        run: |
          PLAN=$(cat .artifacts/PLAN.md)
          echo "plan<<EOF" >> $GITHUB_OUTPUT
          echo "$PLAN" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Read image context
        id: read-images
        if: steps.download-images.outcome == 'success'
        run: |
          if [ -f .artifacts/image-context.md ]; then
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "context<<EOF" >> $GITHUB_OUTPUT
            cat .artifacts/image-context.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "‚úÖ Image context loaded"
          else
            echo "has_images=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Git
        run: |
          git config user.name "Azmi Bot"
          git config user.email "azmi-bot@users.noreply.github.com"

      - name: Create feature branch
        id: branch
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="feature/${ISSUE_KEY}"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Created branch: $BRANCH_NAME"

      - name: Gemini 3 Pro - implement code from plan
        id: gemini-implement
        shell: bash
        run: |
          set -euo pipefail

          echo "üöÄ Starting Gemini 3 Pro implementation..."

          # Read the plan
          PLAN=$(cat .artifacts/PLAN.md)

          # Build the implementation prompt
          cat > .artifacts/implement-prompt.txt << 'PROMPT_EOF'
          You are a senior software engineer implementing code based on a detailed plan.

          TASK: Implement the code changes described in the plan below.

          IMPORTANT OUTPUT FORMAT:
          You must output a JSON object with this exact structure:
          {
            "files": [
              {
                "path": "relative/path/to/file.ts",
                "action": "create" | "modify" | "delete",
                "content": "full file content here"
              }
            ],
            "commit_message": "descriptive commit message",
            "pr_body": "markdown description for PR"
          }

          RULES:
          1. For "create" action: provide the complete new file content
          2. For "modify" action: provide the COMPLETE file content (not just changes)
          3. For "delete" action: content can be empty
          4. Follow the plan exactly - implement all specified changes
          5. Use TypeScript/JavaScript best practices
          6. Include proper error handling
          7. Follow existing code patterns mentioned in the plan

          IMPLEMENTATION PLAN:
          ---
          PROMPT_EOF

          echo "$PLAN" >> .artifacts/implement-prompt.txt

          # Build Gemini request with structured output
          jq -n \
            --rawfile prompt .artifacts/implement-prompt.txt \
            '{
              contents: [{
                role: "user",
                parts: [{text: $prompt}]
              }],
              generationConfig: {
                responseMimeType: "application/json",
                temperature: 0.2,
                maxOutputTokens: 65536
              }
            }' > .artifacts/gemini-implement-request.json

          echo "üì§ Sending implementation request to Gemini 3 Pro..."

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro:generateContent" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @.artifacts/gemini-implement-request.json > .artifacts/gemini-response.json

          echo "üì• Response received"

          # Extract the JSON response
          RESPONSE_TEXT=$(jq -r '.candidates[0].content.parts[0].text' .artifacts/gemini-response.json)
          echo "$RESPONSE_TEXT" > .artifacts/implementation.json

          echo "‚úÖ Implementation plan parsed"

      - name: Apply code changes
        id: apply-changes
        shell: bash
        run: |
          set -euo pipefail

          echo "üìù Applying code changes..."

          # Parse the implementation JSON
          IMPL_JSON=$(cat .artifacts/implementation.json)

          # Process each file
          echo "$IMPL_JSON" | jq -c '.files[]' | while IFS= read -r file; do
            FILE_PATH=$(echo "$file" | jq -r '.path')
            ACTION=$(echo "$file" | jq -r '.action')
            CONTENT=$(echo "$file" | jq -r '.content')

            echo "Processing: $FILE_PATH ($ACTION)"

            case "$ACTION" in
              "create"|"modify")
                # Create directory if needed
                mkdir -p "$(dirname "$FILE_PATH")"
                # Write file content
                echo "$CONTENT" > "$FILE_PATH"
                echo "‚úÖ Written: $FILE_PATH"
                ;;
              "delete")
                if [ -f "$FILE_PATH" ]; then
                  rm "$FILE_PATH"
                  echo "üóëÔ∏è  Deleted: $FILE_PATH"
                fi
                ;;
            esac
          done

          # Extract commit message and PR body
          echo "$IMPL_JSON" | jq -r '.commit_message' > .artifacts/commit-message.txt
          echo "$IMPL_JSON" | jq -r '.pr_body' > .artifacts/pr-body.txt

          echo "‚úÖ All changes applied"

      - name: Commit and push changes
        id: commit
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          # Check if there are changes
          if git diff --quiet && git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No changes to commit"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          git add -A

          # Use commit message from Gemini or default
          if [ -f .artifacts/commit-message.txt ]; then
            COMMIT_MSG=$(cat .artifacts/commit-message.txt)
          else
            COMMIT_MSG="Implement ${ISSUE_KEY}"
          fi

          git commit -m "$COMMIT_MSG

          ü§ñ Implemented by Gemini 3 Pro
          üìã Planned by Claude Opus 4.5"

          git push -u origin "$BRANCH_NAME"

          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Changes committed and pushed to $BRANCH_NAME"

      - name: Create Pull Request
        if: steps.commit.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ISSUE_KEY="${{ github.event.client_payload.issue_key || 'ai-task' }}"
          BRANCH_NAME="${{ steps.branch.outputs.branch_name }}"

          # Build PR body
          if [ -f .artifacts/pr-body.txt ]; then
            PR_DESCRIPTION=$(cat .artifacts/pr-body.txt)
          else
            PR_DESCRIPTION="Implementation for ${ISSUE_KEY}"
          fi

          # Read the plan for PR body
          PLAN=$(cat .artifacts/PLAN.md)

          PR_BODY="## ü§ñ AI Coding - ${ISSUE_KEY}

          ### Implementation Plan (by Claude Opus 4.5)
          <details>
          <summary>Click to expand plan</summary>

          ${PLAN}

          </details>

          ### Changes Made (by Gemini 3 Pro)
          ${PR_DESCRIPTION}

          ---
          üß† **Planned by:** Claude Opus 4.5
          ‚ö° **Implemented by:** Gemini 3 Pro
          "

          # Create PR
          gh pr create \
            --title "AI Coding - ${ISSUE_KEY}" \
            --body "$PR_BODY" \
            --base "${{ env.BASE_BRANCH }}" \
            --head "$BRANCH_NAME"

          echo "‚úÖ Pull Request created"

      - name: Post implementation status to Jira
        if: always()
        env:
          JIRA_BASE: ${{ secrets.JIRA_BASE }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        run: |
          ISSUE_KEY='${{ github.event.client_payload.issue_key }}'

          if [ -z "$ISSUE_KEY" ] || [ "$ISSUE_KEY" = "null" ]; then
            echo "No Jira issue key found, skipping Jira update"
            exit 0
          fi

          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          # Create ADF comment
          jq -n \
            --arg repo "${{ github.repository }}" \
            --arg workflow_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{
              body: {
                type: "doc",
                version: 1,
                content: [
                  {
                    type: "heading",
                    attrs: { level: 2 },
                    content: [{ type: "text", text: "ü§ñ AI Implementation Started" }]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Implementation in progress using Claude Opus 4.5 (planning) + Gemini 3 Pro (coding)." }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Repository: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $repo }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Workflow: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $workflow_url, marks: [{ type: "link", attrs: { href: $workflow_url } }] }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "A pull request will be created shortly and reviewed automatically.", marks: [{ type: "em" }] }
                    ]
                  }
                ]
              }
            }' > /tmp/jira-comment.json

          curl -sS -X POST "$JIRA_BASE/rest/api/3/issue/$ISSUE_KEY/comment" \
            -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d @/tmp/jira-comment.json

          echo "‚úÖ Posted implementation status to Jira issue $ISSUE_KEY"
