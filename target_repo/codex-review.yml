name: Gemini Review and Merge

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write

# Only run for PRs created by AI Coding workflow
jobs:
  check-ai-coding:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check if PR is from AI Coding or Revision
        id: check
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          # Check for various AI PR patterns:
          # 1. Standard format: "AI Coding - ISSUE-KEY" or "AZMI Revision - ISSUE-KEY"
          # 2. Direct JIRA issue format: "ISSUE-KEY | description"
          # 3. Common JIRA prefixes: GET-, AZMI-, DEV-, TASK-

          if [[ "$TITLE" == "AI Coding -"* ]] || \
             [[ "$TITLE" == "AZMI Revision -"* ]] || \
             [[ "$TITLE" =~ ^[A-Z]+-[0-9]+[[:space:]]*\| ]] || \
             [[ "$TITLE" =~ ^(GET|AZMI|DEV|TASK|AI)-[0-9]+ ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "‚úÖ This is an AI PR - will run review"
            echo "PR Title: $TITLE"
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Not an AI PR - skipping review"
            echo "PR Title: $TITLE"
          fi

  gemini-review:
    runs-on: ubuntu-latest
    needs: check-ai-coding
    if: needs.check-ai-coding.outputs.should_run == 'true'
    env:
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      JIRA_BASE: ${{ secrets.JIRA_BASE }}
      JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Check review attempt count (prevent infinite loop)
        id: check-attempts
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          ATTEMPTS=$(gh pr view ${{ github.event.pull_request.number }} --json comments --jq '[.comments[] | select(.body | contains("AI Code Review Summary"))] | length')

          echo "Review attempts so far: $ATTEMPTS"

          if [ "$ATTEMPTS" -ge 3 ]; then
            echo "‚ö†Ô∏è Maximum review attempts reached ($ATTEMPTS/3). Stopping auto-review."
            echo "too_many_attempts=true" >> $GITHUB_OUTPUT

            # Post warning comment
            WARNING_MSG="‚ö†Ô∏è **Maximum AI Review Attempts Reached**\n\nThis PR has been reviewed $ATTEMPTS times by the AI system. Manual review is now required.\n\n**Possible reasons:**\n- Code quality issues that AI cannot fix automatically\n- Complex architectural problems\n- Repeated test failures\n\nPlease review the previous AI feedback and make manual corrections."

            echo -e "$WARNING_MSG" | gh pr comment ${{ github.event.pull_request.number }} --body-file -
          else
            echo "too_many_attempts=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip if too many attempts
        if: steps.check-attempts.outputs.too_many_attempts == 'true'
        run: |
          echo "Stopping workflow - manual review required"
          exit 0

      - name: Fetch PR heads
        run: |
          git fetch --no-tags origin \
            ${{ github.event.pull_request.base.ref }} \
            ${{ github.event.pull_request.head.ref }} \
            +refs/pull/${{ github.event.pull_request.number }}/head

      - name: Extract Jira issue key from PR
        id: jira-key
        run: |
          # Try to extract from PR title first (format: "AI Coding - GET-1234")
          TITLE="${{ github.event.pull_request.title }}"
          ISSUE_KEY=$(echo "$TITLE" | grep -oE '[A-Z]+-[0-9]+' | head -1 || echo "")

          if [ -z "$ISSUE_KEY" ]; then
            # Try from PR body
            ISSUE_KEY=$(echo "${{ github.event.pull_request.body }}" | grep -oE '[A-Z]+-[0-9]+' | head -1 || echo "")
          fi

          echo "issue_key=$ISSUE_KEY" >> $GITHUB_OUTPUT
          echo "Found Jira issue: $ISSUE_KEY"

      - name: Get PR diff for review
        id: get-diff
        run: |
          mkdir -p .artifacts

          # Get the diff between base and head
          git diff origin/${{ github.event.pull_request.base.ref }}...HEAD > .artifacts/pr.diff

          # Get list of changed files
          git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD > .artifacts/changed-files.txt

          echo "üìÑ Changed files:"
          cat .artifacts/changed-files.txt

          echo "diff_size=$(wc -l < .artifacts/pr.diff)" >> $GITHUB_OUTPUT

      - name: Gemini 3 Pro - review PR and generate patch if needed
        id: gemini-review
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Starting Gemini 3 Pro code review..."

          # Read the diff
          DIFF=$(cat .artifacts/pr.diff)
          CHANGED_FILES=$(cat .artifacts/changed-files.txt)

          # Build the review prompt
          cat > .artifacts/review-prompt.txt << 'PROMPT_EOF'
          You are a senior code reviewer. Review ONLY the changes in this PR.

          YOUR TASK:
          1. Evaluate code quality and score 0-100
          2. Identify issues (security, performance, logic, quality)
          3. If there are BLOCKING issues, generate a unified diff patch to fix them

          SCORING CRITERIA:
          - 85-100: Excellent - ready to merge
          - 70-84: Good - minor issues acceptable
          - 50-69: Fair - needs improvement
          - 0-49: Poor - requires major revision

          DEDUCTIONS:
          - Security vulnerabilities: -30 points
          - Logic errors: -20 points
          - Performance issues: -10 points
          - Code quality issues: -5 points
          - Missing tests: -10 points

          OUTPUT FORMAT (JSON):
          {
            "score": <number 0-100>,
            "verdict": "approve" | "request_changes",
            "issues": ["issue 1", "issue 2"],
            "patch": "<unified diff patch if needed, empty string if not>"
          }

          IMPORTANT:
          - Patch should be a valid unified diff that can be applied with `git apply`
          - Only create patches for blocking issues you can fix confidently
          - Score > 80 should generally pass without patches unless critical security issues exist

          CHANGED FILES:
          PROMPT_EOF

          echo "$CHANGED_FILES" >> .artifacts/review-prompt.txt
          echo "" >> .artifacts/review-prompt.txt
          echo "DIFF:" >> .artifacts/review-prompt.txt
          echo '```diff' >> .artifacts/review-prompt.txt
          echo "$DIFF" >> .artifacts/review-prompt.txt
          echo '```' >> .artifacts/review-prompt.txt

          # Build Gemini request
          jq -n \
            --rawfile prompt .artifacts/review-prompt.txt \
            '{
              contents: [{
                role: "user",
                parts: [{text: $prompt}]
              }],
              generationConfig: {
                responseMimeType: "application/json",
                temperature: 0.2,
                maxOutputTokens: 32768
              }
            }' > .artifacts/gemini-review-request.json

          echo "üì§ Sending review request to Gemini 3 Pro..."

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro:generateContent" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @.artifacts/gemini-review-request.json > .artifacts/gemini-review-response.json

          echo "üì• Review response received"

          # Extract the JSON response
          RESPONSE_TEXT=$(jq -r '.candidates[0].content.parts[0].text' .artifacts/gemini-review-response.json)
          echo "$RESPONSE_TEXT" > .artifacts/review-result.json

          echo "‚úÖ Review complete"

      - name: Parse Gemini review result
        id: parse-review
        run: |
          set -e

          echo "üìä Parsing Gemini review result..."

          # Parse JSON response from Gemini
          REVIEW_JSON=$(cat .artifacts/review-result.json)

          # Extract fields from JSON
          SCORE=$(echo "$REVIEW_JSON" | jq -r '.score // 0')
          VERDICT=$(echo "$REVIEW_JSON" | jq -r '.verdict // "request_changes"')
          ISSUES=$(echo "$REVIEW_JSON" | jq -r '.issues | join("\n- ")' || echo "No issues found")
          PATCH=$(echo "$REVIEW_JSON" | jq -r '.patch // ""')

          # Validate score is a number
          if ! [[ "$SCORE" =~ ^[0-9]+$ ]] || [ -z "$SCORE" ]; then
            echo "‚ö†Ô∏è Warning: Invalid score, defaulting to 0"
            SCORE=0
          fi

          echo "Score: $SCORE"
          echo "Verdict: $VERDICT"

          # Check if patch exists
          if [ -n "$PATCH" ] && [ "$PATCH" != "null" ] && [ "$PATCH" != "" ]; then
            echo "has_patch=true" >> $GITHUB_OUTPUT
            echo "$PATCH" > .artifacts/gemini.patch
            echo "üìù Patch extracted to .artifacts/gemini.patch"
          else
            echo "has_patch=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No patch needed"
          fi

          echo "score=$SCORE" >> $GITHUB_OUTPUT
          echo "verdict=$VERDICT" >> $GITHUB_OUTPUT

          # Save issues (multi-line safe)
          echo "issues<<EOF" >> $GITHUB_OUTPUT
          echo "$ISSUES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Determine if PR should proceed (score > 80)
          if [ "$SCORE" -gt 80 ]; then
            echo "should_proceed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Score: $SCORE - PR can proceed"
          else
            echo "should_proceed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Score: $SCORE - PR needs revision"
          fi

      - name: Apply Gemini patch if exists
        if: steps.parse-review.outputs.has_patch == 'true'
        run: |
          echo "üîß Applying Gemini patch..."

          # Ensure we're on the correct branch
          git checkout -B ${{ github.event.pull_request.head.ref }}
          git branch --set-upstream-to=origin/${{ github.event.pull_request.head.ref }}

          # Apply patch with whitespace fixing
          if git apply --whitespace=fix .artifacts/gemini.patch; then
            echo "‚úÖ Patch applied successfully"

            # Commit the changes
            git config user.name "Azmi Bot"
            git config user.email "azmi-bot@users.noreply.github.com"
            git add -A
            git commit -m "Fix: Apply Gemini review patch (Score: ${{ steps.parse-review.outputs.score }})"

            # Push with explicit ref
            git push origin HEAD:${{ github.event.pull_request.head.ref }}

            echo "‚úÖ Patch committed and pushed"
          else
            echo "‚ùå Patch failed to apply - will request manual fix"
            exit 0
          fi

      - name: Gemini 3 Pro - evaluate and fix remaining issues
        if: steps.parse-review.outputs.issues != '' && steps.parse-review.outputs.should_proceed != 'true'
        id: gemini-fix
        shell: bash
        run: |
          set -euo pipefail

          echo "üîß Starting Gemini 3 Pro issue fixing..."

          ISSUES='${{ steps.parse-review.outputs.issues }}'
          SCORE='${{ steps.parse-review.outputs.score }}'

          # Read current file contents for context
          CHANGED_FILES=$(cat .artifacts/changed-files.txt)

          # Build the fix prompt
          cat > .artifacts/fix-prompt.txt << PROMPT_EOF
          You are a senior software engineer fixing code review issues.

          CONTEXT:
          - Repository: ${{ github.repository }}
          - PR Branch: ${{ github.event.pull_request.head.ref }}
          - Review Score: ${SCORE}/100

          REVIEW FINDINGS TO FIX:
          ${ISSUES}

          CHANGED FILES:
          ${CHANGED_FILES}

          YOUR TASK:
          1. Analyze each issue
          2. For CRITICAL and HIGH severity issues, generate fixes
          3. Skip LOW severity or false positives

          OUTPUT FORMAT (JSON):
          {
            "fixes_applied": true | false,
            "files": [
              {
                "path": "relative/path/to/file.ts",
                "content": "complete fixed file content"
              }
            ],
            "summary": "description of fixes applied"
          }

          IMPORTANT:
          - Only fix issues that are clearly bugs or security problems
          - Provide COMPLETE file content, not just patches
          - If no fixes needed, set fixes_applied to false
          PROMPT_EOF

          # Build Gemini request
          jq -n \
            --rawfile prompt .artifacts/fix-prompt.txt \
            '{
              contents: [{
                role: "user",
                parts: [{text: $prompt}]
              }],
              generationConfig: {
                responseMimeType: "application/json",
                temperature: 0.2,
                maxOutputTokens: 65536
              }
            }' > .artifacts/gemini-fix-request.json

          echo "üì§ Sending fix request to Gemini 3 Pro..."

          curl -sS "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro:generateContent" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @.artifacts/gemini-fix-request.json > .artifacts/gemini-fix-response.json

          # Extract and apply fixes
          RESPONSE_TEXT=$(jq -r '.candidates[0].content.parts[0].text' .artifacts/gemini-fix-response.json)
          echo "$RESPONSE_TEXT" > .artifacts/fix-result.json

          FIXES_APPLIED=$(echo "$RESPONSE_TEXT" | jq -r '.fixes_applied')
          SUMMARY=$(echo "$RESPONSE_TEXT" | jq -r '.summary // "No fixes applied"')

          if [ "$FIXES_APPLIED" = "true" ]; then
            echo "üìù Applying fixes..."

            # Apply each file fix
            echo "$RESPONSE_TEXT" | jq -c '.files[]' | while IFS= read -r file; do
              FILE_PATH=$(echo "$file" | jq -r '.path')
              CONTENT=$(echo "$file" | jq -r '.content')

              mkdir -p "$(dirname "$FILE_PATH")"
              echo "$CONTENT" > "$FILE_PATH"
              echo "‚úÖ Fixed: $FILE_PATH"
            done

            # Commit fixes
            git config user.name "Azmi Bot"
            git config user.email "azmi-bot@users.noreply.github.com"
            git add -A
            git commit -m "AI Review Fixes: Address Gemini findings (Score: $SCORE)

            $SUMMARY"
            git push origin ${{ github.event.pull_request.head.ref }}

            echo "‚úÖ Fixes committed and pushed"
          else
            echo "‚ÑπÔ∏è No fixes needed: $SUMMARY"
          fi

          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Post review summary as comment
        uses: actions/github-script@v7
        with:
          script: |
            const score = '${{ steps.parse-review.outputs.score }}';
            const verdict = '${{ steps.parse-review.outputs.verdict }}';
            const issuesRaw = ${{ toJSON(steps.parse-review.outputs.issues) }};
            const geminiFix = '${{ steps.gemini-fix.outputs.summary }}' || 'No fixes needed';

            const issues = issuesRaw || '';

            const geminiSummary = issues ? '**Issues Found:**\n- ' + issues : '**No major issues found**';

            // Determine status emoji
            const statusEmoji = score >= 85 ? '‚úÖ' : score >= 70 ? '‚ö†Ô∏è' : '‚ùå';

            const body = '## ' + statusEmoji + ' AI Code Review Summary\n\n' +
              '**Gemini 3 Pro Score**: ' + score + '/100\n' +
              '**Verdict**: ' + verdict + '\n\n' +
              '### üìã Review Findings\n' +
              geminiSummary + '\n\n' +
              '---\n\n' +
              '### üîß Auto-Fix Summary\n' +
              geminiFix + '\n\n' +
              '---\n\n' +
              '**Next Steps:**\n' +
              (score > 80 ? '‚úÖ PR approved - will auto-merge if checks pass' : '‚ùå PR needs revision - score too low (threshold: 80)') + '\n\n' +
              '---\nü§ñ Reviewed by Gemini 3 Pro';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: body
            });

      - name: Approve PR if score > 80
        if: steps.parse-review.outputs.should_proceed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              event: "APPROVE",
              body: `‚úÖ LGTM - Gemini 3 Pro Score: ${{ steps.parse-review.outputs.score }}/100 (threshold: 80)`
            });

      - name: Post review summary to Jira
        if: steps.jira-key.outputs.issue_key != ''
        run: |
          ISSUE_KEY="${{ steps.jira-key.outputs.issue_key }}"

          if [ -z "$ISSUE_KEY" ]; then
            echo "No Jira issue found, skipping Jira update"
            exit 0
          fi

          mkdir -p .artifacts

          # Save variables to files to avoid shell escaping issues
          echo -n "${{ github.event.pull_request.html_url }}" > .artifacts/pr_url.txt
          echo -n "${{ steps.parse-review.outputs.score }}" > .artifacts/score.txt
          echo -n "${{ steps.parse-review.outputs.verdict }}" > .artifacts/verdict.txt
          echo -n "${{ steps.parse-review.outputs.issues }}" > .artifacts/issues.txt
          echo -n "${{ steps.gemini-fix.outputs.summary }}" > .artifacts/gemini_fix.txt

          SCORE=$(cat .artifacts/score.txt)
          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          # Determine review status based on score
          if [ "$SCORE" -gt 50 ]; then
            echo -n "‚úÖ Approved (Score: $SCORE/100)" > .artifacts/status.txt
          else
            echo -n "‚ùå Changes Requested (Score: $SCORE/100)" > .artifacts/status.txt
          fi

          # Create ADF (Atlassian Document Format) comment using file-based jq
          jq -n \
            --rawfile status .artifacts/status.txt \
            --rawfile pr_url .artifacts/pr_url.txt \
            --rawfile score .artifacts/score.txt \
            --rawfile verdict .artifacts/verdict.txt \
            --rawfile issues .artifacts/issues.txt \
            --rawfile gemini_fix .artifacts/gemini_fix.txt \
            '{
              body: {
                type: "doc",
                version: 1,
                content: [
                  {
                    type: "heading",
                    attrs: { level: 2 },
                    content: [{ type: "text", text: "ü§ñ AI Code Review Completed" }]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Status: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $status }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Score: ", marks: [{ type: "strong" }] },
                      { type: "text", text: ($score + "/100") }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Reviewed by: ", marks: [{ type: "strong" }] },
                      { type: "text", text: "Gemini 3 Pro" }
                    ]
                  },
                  {
                    type: "paragraph",
                    content: [
                      { type: "text", text: "Pull Request: ", marks: [{ type: "strong" }] },
                      { type: "text", text: $pr_url, marks: [{ type: "link", attrs: { href: $pr_url } }] }
                    ]
                  },
                  {
                    type: "heading",
                    attrs: { level: 3 },
                    content: [{ type: "text", text: "üìã Review Findings:" }]
                  },
                  {
                    type: "paragraph",
                    content: [{ type: "text", text: ($issues | if . == "" then "No major issues found" else . end) }]
                  },
                  {
                    type: "heading",
                    attrs: { level: 3 },
                    content: [{ type: "text", text: "üîß Auto-Fix Summary:" }]
                  },
                  {
                    type: "paragraph",
                    content: [{ type: "text", text: ($gemini_fix | if . == "" then "No fixes applied" else . end) }]
                  }
                ]
              }
            }' > .artifacts/jira-comment.json

          echo "üì§ Posting review comment to Jira..."

          curl -sS -X POST "$JIRA_BASE/rest/api/3/issue/$ISSUE_KEY/comment" \
            -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d @.artifacts/jira-comment.json

          echo "‚úÖ Posted review summary to Jira issue $ISSUE_KEY"

      - name: Move Jira issue to Review status
        if: steps.jira-key.outputs.issue_key != ''
        run: |
          ISSUE_KEY="${{ steps.jira-key.outputs.issue_key }}"

          if [ -z "$ISSUE_KEY" ]; then
            echo "No Jira issue found, skipping status transition"
            exit 0
          fi

          AUTH=$(printf "%s:%s" "$JIRA_EMAIL" "$JIRA_API_TOKEN" | base64 | tr -d '\n')

          # Get available transitions for this issue
          TRANSITIONS=$(curl -sS -X GET "$JIRA_BASE/rest/api/3/issue/$ISSUE_KEY/transitions" \
            -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json")

          echo "Available transitions:"
          echo "$TRANSITIONS" | jq '.transitions[] | {id: .id, name: .name}'

          # Find transition ID for "Review" status (try common names)
          TRANSITION_ID=$(echo "$TRANSITIONS" | jq -r '.transitions[] | select(.name | test("Review|In Review|Code Review"; "i")) | .id' | head -1)

          if [ -z "$TRANSITION_ID" ] || [ "$TRANSITION_ID" = "null" ]; then
            echo "‚ö†Ô∏è No 'Review' transition found for issue $ISSUE_KEY"
            echo "Available transitions are listed above. Please configure Jira workflow."
            exit 0
          fi

          # Perform transition
          TRANSITION_BODY=$(jq -n --arg id "$TRANSITION_ID" '{transition: {id: $id}}')

          curl -sS -X POST "$JIRA_BASE/rest/api/3/issue/$ISSUE_KEY/transitions" \
            -H "Authorization: Basic $AUTH" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            --data "$TRANSITION_BODY"

          echo "‚úÖ Moved Jira issue $ISSUE_KEY to Review status (transition ID: $TRANSITION_ID)"

      - name: Merge PR if score > 80
        if: steps.parse-review.outputs.should_proceed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            try {
              const score = '${{ steps.parse-review.outputs.score }}';

              // Force merge with admin token - bypasses branch protection
              const result = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                merge_method: "squash",
                commit_title: `${context.payload.pull_request.title} (#${context.payload.pull_request.number})`,
                commit_message: `‚úÖ Auto-merged after AI Review (Gemini 3 Pro Score: ${score}/100)`
              });
              core.info(`‚úÖ Merged successfully: ${result.data.message}`);
            } catch (e) {
              core.error(`‚ùå Merge failed: ${e.message}`);

              // Detailed diagnostics
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });

              core.info(`PR State: ${pr.data.state}`);
              core.info(`Mergeable: ${pr.data.mergeable}`);
              core.info(`Mergeable State: ${pr.data.mergeable_state}`);
              core.info(`Merged: ${pr.data.merged}`);

              if (pr.data.mergeable_state === 'blocked') {
                core.warning('‚ö†Ô∏è PR is blocked. Check branch protection rules or failing checks.');
              }

              throw e;
            }
